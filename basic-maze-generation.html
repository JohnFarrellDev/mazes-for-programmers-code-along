<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Mazes for Programmers Code Along</title>
    <link rel="stylesheet" href="/src/styles/base.css" />
    <link rel="stylesheet" href="/src/styles/prism.css" />
  </head>
  <body id="app">
    <main class="container">
      <h1 class="heading">Generating Basic Mazes</h1>
      <div class="page-content">
        <p>
          At this early stage in the book all mazes are simple 2D rectangle. Due
          to this simplicity we can represent mazes as 2 dimensional arrays. The
          only inputs for generating the size of the maze will be providing a
          width and height.
        </p>
        <p>
          Initially lets generate a basic 2D grid where each cell inside the
          grid displays its row index followed by the column index
        </p>

        <pre class="language-html">
import { Cell } from &quot;./cell&quot;;

export class Maze {
  #cells: Array&lt;Array&lt;Cell&gt;&gt;;

  constructor(width: number, height: number) {
    this.#cells = Array.from({ length: height }, (_, rowIndex) =&gt; {
      return Array.from({ length: width }, (_, columnIndex) =&gt; {
        return new Cell(rowIndex, columnIndex);
      });
    });
  }

  get cells() {
    return this.#cells;
  }
}
</pre
        >

        <p>
          To take our 2D array we need to have a render function, considering we
          may represent out mazes in various ways we will create a maze_render
          interface which classes can implement. This function will be designed
          to take in a Maze and return HTML, this could later be extended to the
          Canvas API, SVGs or WebGL.
        </p>

        <pre class="language-html">
import type { Maze } from &quot;./maze&quot;;

export interface Maze_Render {
  render(maze: Maze): HTMLDivElement;
}
</pre
        >

        <p>
          First lets generate a grid from our 2D Maze array and correctly
          identify each column and row within the grid, first we produce our
          Numerical_Maze class which implements the Maze_Renderer interface.
        </p>

        <pre class="language-html">
import { create_div } from &quot;../components/create_div&quot;;
import { Maze } from &quot;./maze&quot;;
import type { Maze_Render } from &quot;./maze_renderer&quot;;

export class Numerical_Maze implements Maze_Render {
  render(maze: Maze): HTMLDivElement {
    const container = create_div({ id: &quot;maze-container-numerical&quot; });

    maze.cells.forEach((row) =&gt; {
      const row_container = create_div();
      row_container.style.display = &quot;flex&quot;;

      row.forEach((cell) =&gt; {
        const cell_element = create_div();

        cell_element.style.width = &quot;40px&quot;;
        cell_element.style.height = &quot;40px&quot;;
        cell_element.style.display = &quot;grid&quot;;
        cell_element.style.placeItems = &quot;center&quot;;

        cell_element.textContent = `${cell.column + cell.row * row.length}`;

        row_container.append(cell_element);
      });

      container.appendChild(row_container);
    });

    return container;
  }
}
</pre
        >
        <p>
          And with that code we can make a Maze with a width of 6 and a height
          of 8, pass it to our Numerical_Maze render function and return the
          below HTML.
        </p>
        <div id="basic-maze-container"></div>
        <p>
          Next step we'll add some border styling and remove the text. Let's
          create a Bordered_Maze class with implements Maze_Renderer as well.
        </p>
        <pre class="language-html">
import { create_div } from &quot;../components/create_div&quot;;
import { Maze } from &quot;./maze&quot;;
import type { Maze_Render } from &quot;./maze_renderer&quot;;

export class Bordered_Maze implements Maze_Render {
  render(maze: Maze): HTMLDivElement {
    const container = create_div({ id: &quot;maze-container-bordered&quot; });

    maze.cells.forEach((row, row_index) =&gt; {
      const row_container = create_div();
      row_container.style.display = &quot;flex&quot;;

      row.forEach((cell, column_index) =&gt; {
        const cell_element = create_div();

        cell_element.style.width = &quot;40px&quot;;
        cell_element.style.height = &quot;40px&quot;;

        // north
        if (cell.borders[0]) {
          cell_element.style.borderTop = &quot;2px solid white&quot;;
        }
        // west
        if (cell.borders[3]) {
          cell_element.style.borderLeft = &quot;2px solid white&quot;;
        }
        // south — only bottom edge
        if (cell.borders[2] &amp;&amp; row_index === maze.cells.length - 1) {
          cell_element.style.borderBottom = &quot;2px solid white&quot;;
        }
        // east — only rightmost edge
        if (cell.borders[1] &amp;&amp; column_index === maze.cells[0].length - 1) {
          cell_element.style.borderRight = &quot;2px solid white&quot;;
        }

        row_container.append(cell_element);
      });

      container.appendChild(row_container);
    });

    return container;
  }
}
</pre
        >
        <p>
          We can take the same maze object as before and now pass it to the
          Bordered_Maze render function and return the below.
        </p>
        <div id="basic-maze-container-bordered"></div>
        <p>
          Now we can see that if we were to remove some of the borders around
          each cell we could construct a reasonable looking maze. This will be
          where out first algorithm comes in, the binary tree algorithm.
        </p>
        <p>
          The binary tree algorithm requires us to visit every cell in the maze
          once, this can be done in any order. At each cell we make a 50/50
          choice to either remove the top border or the right border.
        </p>
        <p>
          For the very top row of cells we cannot remove the top border so must
          remove the border to the right. For the cells on the very right we
          must remove the top border.
        </p>
        <p>
          While this algorithm is very simple and easy you will see that it has
          some drawbacks, the generated maze has a certain predictable pattern
          to it which makes it easy to solve.
        </p>
      </div>
    </main>
    <script type="module" src="/src/main.ts"></script>
    <script
      type="module"
      src="/src/pages/basic-maze-generation/basic-maze-generation.ts"
    ></script>
  </body>
</html>
